<center> <h1>Mysql事务

> 事务的四大特性

`原子性`：事务是最小的执行单元，一个事务要么都执行，要么都不执行

`隔离性`:一个事务对于其他正在执行的事务是不可见的，各个事务之间是互不干扰的。

`一致性`:事务的执行使得数据库从一个一致性状态转换为另一个一致性状态。

`持久性`:事务执行的操作将会被持久化到数据库中。

`事务确保了一系列的操作要么全部执行，要么全部不执行`

> 实现原理

由于操作本身是不具备原子性，并且可以在细分为多个操作，如果在操作出现错误的时候，就会造成一个问题，已经执行成功的操作，对数据库进行了修改，但是本身这个操作是失败的，那么如何确定数据库中数据的一致性呢？

`要想保证事务的原子性，就需要在异常发生的时候，对已经执行的操作进行回滚`，而在Mysql中，恢复机制是通过`回滚日志(undo log)`来实现的，`所有事务对数据库进行修改的操作都会被记录到回滚日志中，然后在事务执行成功之后，在往数据库对应的行进行写入。`

其实这个过程是很好理解的，因为如果需要在发生错误的时候，回滚本次执行的操作，那么就首先需要对本次执行的操作进行记录。只有这样，才能根据记录进行回滚。

`回滚日志除了能够在发生错误或者用户手动执行ROLLBACK的时候，提供回滚的相关信息，他还能够在系统崩溃之后，进程死掉之后，当用户再次启动数据库的时候，能够直接查询回滚日志对之前没有执行成功的事务，进行回滚。`，这样的话，就需要一个优先级，那就是回滚日志必须先于数据库操作进行持久化，因为需要根据回滚日志进行数据恢复。

回滚日志并不能将数据库完全恢复到和执行事务之前完全一样的样子，回滚日志是逻辑日志，当回滚日志被使用的时候，也就是说，如果我们在事务中执行的是insert操作，那么在回滚日志中就会写入一个delete操作，如果执行的是update操作，那么就会写入一条反向的update语句。

> 事务的状态

事务的状态只有三种`Active, Committed、Failed`状态，即事务要么处在被激活的状态中，要么就是执行陈工，要么执行失败。但是事务的状态还可以被细分为其他很多状态，包括`Partially Commited`和`Aborted`

- Active：事务的初始状态，表示事务正在执行；
- Partially Commited：在最后一条语句执行之后；
- Failed：发现事务无法正常执行之后；
- Aborted：事务被回滚并且数据库恢复到了事务进行之前的状态之后；
- Commited：成功执行整个事务

> 并行事务的原子性

在实际的情况下，事务的执行很少是串行执行的，一般都是并发执行的，然而并发执行就会导致更加复杂的数据库状态和更加多样的情况发生。

情况一:

`如果存在两个并行的事务，事务一对数据库id为1的数据进行了读写操作，但是并没有将事务进行提交，事务二同样对id为1的数据进行了读操作，并且已经成功的将事务进行了提交，此时，由于某些原因么，事务一遇到了某些错误需要进行回滚，但是事务二已经进行了提交，是没有办法执行回滚的。`那么这个情况下，我们需要怎样来进行恢复呢？

简单的来说，如果事务二的操作依赖于事务一，那么我们就需要在事务二进行提交之前对事务一进行提交操作。

> 持久性

`既然是关系型数据库，那么就需要数据可以被安全的存储到磁盘中，而事务的持久性就要求事务成功执行之后，数据一定会被写入到磁盘中去。`

当一个事务执行成功之后，就无法进行回滚了，唯一能够撤回已经提交的事务的方式就是创建一个相反的事务对原操作进行『补偿』，这也是事务持久性的体现之一。

`重做日志`

和事务的原子性一样，事务的持久性也是通过日志来实现的，Mysql使用`重做日志(redo log)`来实现持久性，重做日志由两部分组成，`一个是内存中的重做日志缓冲区，一个是磁盘上的重做日志文件`，因为重做日志缓冲区是放在内存中的，比较容易丢失，所以还需要磁盘中的重做日志文件来进行持久化。

`当我们在事务中对数据进行修改的时候，会首先将数据从磁盘加载到内存中。并且更新内存中的缓存数据，然后生成一条重做日志并且写入重做日志缓存，当事务真正提交的时候，Mysql会将重做日志缓冲区的内容刷新到重做日志文件中去，在将内存中的数据刷回磁盘中`

![](/Users/wangdong/Desktop/2019-02-21-Redo-Logging.png)

除了对数据库的所有修改会生成重做日志之外，因为回滚日志也是需要持久化存储的，所以也会生成对应的重做日志。在发生错误的时候，数据库进行重启时会从重做日志中找出未被更新到数据库磁盘中的日志重新执行一次，来满足持久性的要求。

> 回滚日志和重做日志

`在数据库中，事务的原子性和持久性就是通过上面的两种日志来实现的，前者对事务产生的影响进行撤销，后者在错误发生的的时候对数据库进行重做`

> 数据库隔离性

1. Mysql数据库有4中数据库隔离级别,分别为`READ COMMITTED、READ UNCOMMITTED、REPEATABLE READ 以及SERIALIZABLE`

`READ UNCOMMITTED`:在进行读取操作的时候，不加任何锁，可能会读取到未提交的数据。

`READ COMMITTED`： 在进行读取操作的时候，会加行锁，但不会加间隙锁，所以会允许新的记录插入到当前记录的附近，所以在进行多次查询的时候，可能会得到不同的结果，这种现象也叫做不可重复读。

`REPEATABLE READ`:在进行读取操作的时候，多次读取同一范围内的数据的时候，只会返回第一次查询的快照，不会返回不同的行，但是可能发生幻读。

`SERIALIZABLE`:会将全部的查询语句加上读锁，会强制事务串行化执行，对并发性能影响比较大。

> 隔离级别的实现

不同数据库之间实现隔离级别有不同的方式，下面介绍三种常见的隔离级别的实现方式

1. `锁`：通过加锁，锁住当前事务操作的行，可以实现数据库的隔离性
2. `时间戳`：数据库中会为每一条记录保留两个字段，分别是`读时间戳`和`写时间戳`,读时间戳包括了所有访问该记录的事务中最大的时间戳，写时间戳保存了将记录改到当前值的时间戳。使用时间戳的方式实现数据库隔离级别的时候，多数采用的是乐观锁的实现方式，先将数据进行修改，在写入数据库的时候，判断当前记录的时间戳是否发生了改变，如果发生了改变的话，就生成一个新的时间戳，然后再将数据进行写入，如果没有发生改变的情况下，就直接进行写入。乐观锁并不是一种真正意义上的锁，而是一种思想，通过判断数据是否发生改变，来实现对应数据库的操作。
3. `多版本和快照隔离`:通过维护多个版本的数据，数据库可以允许事务在数据被其他事务更新的时候对旧版本的数据进行读取，也就是Mysql实现的MVCC方式。
4. 