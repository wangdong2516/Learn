# 正则表达式
## 入门
### 一、匹配开头和结尾
	1. 匹配开头：使用的是^(脱字符)
	2. 匹配结尾；使用的是$
	3. 注意：关于匹配开头和结尾的理解：例如，匹配^cat应该理解成
		匹配以c开头，后面的一个字符是a，再后面的一个字符是t，而不是理解为匹配以cat开头的，结尾的匹配也是类似的
### 二、匹配若干字符或者是范围
	1. 匹配若干字符：[.....]	匹配方括号中列出的任意一个字符
		注意：
			1. 当元字符(比如.,*,^这样的字符出现在[]中的时候，他们的含义已经发生了变化)
				比如：c[.]t在这里只能匹配文本c.t的内容，而不是中间是任意字符
			2. 连字符在字符组中表示范围(只有在连字符出现在[]中，并且不是第一位的时候，才表示范围)，如果连字符出现在[]中第一个的时候，只是一个普通的-
				比如：1[0-9,a-z,A-Z]可以匹配1后面是0-9数字，a-z小写字母或者是A-Z大写字母
				而a[-,a-z]匹配的是字符a，后面是一个连字符-，或者是a-z的字母
				* 注意：re.match()是默认从头开始匹配的
	2. 匹配不是列举字符的字符
		1. 使用[^]可以匹配不再[]列举范围内的任意一个字符，并且只有当^出现在[]中第一位的时候，才表示的是取反的操作
		2. 关于^的理解：应该是理解成匹配一个未列出的字符，
			比如：a[^0-9],表示的是匹配a后面只要不是0-9的数字就可以匹配到。
			a[a^9]表示的是匹配a后面是a或者是^或者是9的两个字符的文本,这个时候，^就变成了一个普通字符来进行匹配了
### 三、匹配任意字符
	1. 匹配任意字符：使用.匹配任意字符(非换行符\n，\n是不能被.匹配的)
	2. 匹配任意字符的方式比较容易理解，但是不够细致，使用哪种匹配模式是你需要根据你对文本的了解情况指定的，
		如果使用匹配任意字符的方案一定不会出现意外结果的话，就是可以使用的.
### 四、多选结构
	1. 匹配任意子表达式：| 意思是or
	2. 注意：比如需要匹配一个gr[ea]y的单词，可以写成grey| gray，或者是写成gr(a|e)y，但是不能写成gr[e|a]y，因为
		|位于字符组中，这时候表示的就是一个普通字符|，而不是元字符|能表达式or的意思了
	3。 多选结构可以包括很多字符，但是不能超过括号的界限
	4. 注意：
		多选结构和字符组的区别：字符组一次只能匹配一个字符，但是多选结构本身也可以是一个正则表达式，可以匹配任意长度的文本。
		多选结构能匹配到的文本都是由括号的限制的，在一个多选结构中使用^和$的时候，也要十分的小心
### 五、忽略大小写
	1. 当使用re模块进行正则匹配的时候，如果需要忽略大小写，需要使用flags参数，并且指定re.IGNORECASE
		或者是在进行正则表达式编译的时候，将re.IGNORECASE传入re.compile的构造函数中
		text = 'UPPER PYTHON, lower python, Mixed Python'
		re.findall('python', text, flags=re.IGNORECASE) ---> ['PYTHON', 'python', 'Python']
		或者是：
		a = re.compile('python', flags=re.IGNORECASE)
		a.findall(text)
## python中的re模块
	1. \b： 匹配一个单词的边界，例如'ey\b'匹配vareyey中的最后一个ey，但是不匹配中间的ey	2. re模块中的元字符：. ^ $ * + ? { } [ ] \ | ( )
		.: 在默认模式下，匹配除了换行符的任何字符，在DOTALL模式下，也可以匹配换行符
		^: 匹配字符串的开头，在MULTILINE模式下，也可以匹配字符串换行之后的首个字符
		$: 匹配字符串的结尾，在MULTILIINE模式下，匹配换行符前面的一个字符
		*: 匹配前面的内容出现0次或者是任意次
		+: 匹配前面的内容出现至少1次
		？: 匹配前面的内容出现0次或者是1次
		*？,.?,??: 禁止*，.和？的贪婪模式匹配
		{m}: 匹配前面的内容重复m次
		{m,n}: 匹配前面的内容重复m次到n次
		{m,n}?: 匹配前面的内容重复m次到n次，并且在m和n中取最小值，相当于{m}
		\: 转义字符，或者表示一个特殊的序列，因为反斜杠的问题，建议在正则表达式前加r
		[]: 字符组
			在一个字符组中，字符可以单独列出
			可以表示字符的范围，通过使用-将两个字符连接起来，如果对-进行了转义，或者是-没有出现在字符组中第一个字符的位置，那将被认为是一个普通字符
			特殊字符在字符组中，将失去特殊字符本身的含义，变为普通字符
			字符类(\w,\s)在字符组中是可以接受的
			不在字符组范围内的字符可以通过取反来实现，^表示所有不再字符组中的字符都将被匹配
		|: 分支结构（or）可以匹配左右两边的任意正则表达式，如果要匹配'|'，需要使用\进行转义
		(): 分组（组合），匹配括号内任何的正则表达式，并且标识出组合的开始和结尾，匹配完成之后，组合的内容可以被获取
		(?P<name>): 命名组合，组合名必须是有效的python标识符，并且每个组合的名字只能用一个正则表达式进行定义，只能定义一次
	3. re模块的特殊序列：
			\d --> 匹配任何十进制数字；这等价于类 [0-9]。
			\D --> 匹配任何非数字字符；这等价于类 [^0-9]。
			\s --> 匹配任何空白字符；这等价于类 [ \t\n\r\f\v]。
			\S --> 匹配任何非空白字符；这相当于类 [^ \t\n\r\f\v]。
			\w -->匹配任何字母与数字字符；这相当于类 [a-zA-Z0-9_]。
			\W --> 匹配任何非字母与数字字符；这相当于类 [^a-zA-Z0-9_]。
			\b --> 匹配单词的边界，匹配的只是一个位置，这个位置的一侧是构成单词的字符，另一侧为非单词字符，字符串的开始或者是结尾的位置
					正则表达式中的单词就是由\w所定义的字符组成的子串
	4. 匹配重复：
		*： 表示前面的一个字符重复0次或者无数次
		+： 表示前面的一个字符重复至少一次
		?: 表示前面的一个字符重复零次或者一次
		{m,n}: 表示前面的一个字符出现m次到n次,上下限都包含
		{m,}: 匹配前面的一个字符出现至少m次
	5. 编译正则表达式：
		pattern = re.compile(正则表达式，flags=参数)
		正则表达式被编译成模式对象，模式对象具有各种操作方法，替换和匹配等
		flags参数用于启用特殊的功能或者是语法变体
		经常使用的flags参数的值有：re.IGNORECASE --> 忽略大小写
		几种经常使用的模式对象的方法：
			1. match(): 确定正则是否从字符串的开头进行匹配，如果可以匹配到返回一个子串
			2. search(): 扫描字符串，查找此正则匹配的任何位置
			3. findall(): 找到正则匹配的所有子字符串，并将他们作为一个列表进行返回。
			4. finditer(): 找到正则匹配的所有子字符串，并且将他们作为一个迭代器,遍历之后，使用span()获取匹配到的内容。
			*注意： 如果没有匹配到，match()和search()返回的是None，如果匹配成功，会将匹配到的对象返回，包含匹配的相关信息：起始位置和终止位置，匹配到的子串和其他信息
		几种获取匹配对象匹配的信息的方法：
			1. group(): 返回正则匹配的字符串，可以一次传递多个组号，将返回一个包含这些组相应值的元祖，默认的组号是0
			2. groups(): 返回一个元祖，其中包含所有子组的字符串
			2. start(): 返回匹配的开始位置
			3. end(): 返回匹配的结束位置
			4. span(): 返回包含匹配位置的元祖--> (start,end)
	6. 模块级别的函数
		1. 不是必须创建模式对象并且调用模式对象的方法来获取匹配的内容(但是模式对象的性能比普通函数的性能好)，re模块提供了顶级函数match(), search(), findall(), sub()等
		这些函数采用和模式方法相同的参数，并且将正则表达式字符串作为第一个参数传入，并且任然返回None或者是匹配对象
	7. 编译标志：
		1. 编译标志允许你修改正则表达式的工作方式
		2. 常见的编译标志：
			1. ASCII，A: 使几个转义如\w,\b,\s,\d仅与具有相应特征属性的ASCII字符匹配
			2. DOTALL，S: 使.也能对换行符进行匹配
			3. IGNORECASE, I: 进行忽略大小写的匹配
			4. LOCALE, L: 进行区域设置感知匹配
			5. MULTILINE, M,: 多行皮撇，影响^和$
			6. VERBOSE, X: 启用详细的正则，可以更加清晰，更加容易理解
	8. 元字符：
		1. 零宽度断言：他们不会使解析引擎在字符串中前进一个字符，他们根本不占用任何字符，只是成功或者是失败
		2. |： or运算符，a|b将匹配任何与a或者是b匹配的字符串，另外|具有非常低的优先级
			如果要匹配字面量'|',必须使用\对元字符|进行转义，或者将|放在字符组中[|]
			^: 在行的开头进行匹配，除非设置了MULTILINE标志，否则只会在字符串的开头进行匹配，在MULTILINE模式下，这也在字符串中的每个换行符之后立即匹配
			要匹配字面量的'^'，需要使用\^进行转义
			$: 匹配行的末尾，定义为字符串的结尾，或者后面跟换行符的任何位置
			\A: 仅匹配字符串的开头，当不是MULTILINE模式下的时候，\A和^是相同的，在MULTILINE模式的时候，\A任然只是在字符串的开头进行匹配
			但是^可以匹配在换行符之后的字符串的任何位置
			\Z:：只匹配字符串的结尾
			\b:字边界，仅在单词的开头或者是结尾处进行匹配，当它包含在另一个单词中的时候不会进行匹配
			例如：
				p = re.compile(r'\bclass\b')
				p.search('this is a class') --> class
				p.search('this is a declassified') --> None
				p.search('one subclass is') --> None
			*注意：在使用字边界进行匹配的时候，会和python产生冲突，在python的字符串文本中，\b是退格字符，如果不使用原始字符串的时候，可能不会按预期的工作。
			\B:与\b的含义相反，仅在当前位置不在字边界的时候进行匹配
	9. 分组：
		1. 模式中的后向引用规定了必须在字符串中找到当前捕获组的内容，可以找到为成功，找不到为失败。
		2. 组从1开始编号
	10. 修改字符串
		1. split(): 将字符串拆分为一个列表，在正则匹配到的任何地方将其拆分。有两个参数，第一个参数是分隔符，第二个参数是分隔的次数，不指定的话，默认是全部分隔。
		2. sub(): 找到正则匹配到的所有子字符串，并且用不同的字符串替换,
			可以指定替换的次数，不指定的话，默认全部替换，替换的次数必须是一个非负的整数。
			模式对象.sub(replace, string, count)其中count是可选的参数
			re.sub(正则表达式, replace,string, count)其中count是可选参数
		3. subn(): 与sub()相同，但是返回新的字符串和替换的次数
	11. 贪婪和非贪婪
		1. *，., 和？都默认是贪婪的，他们在字符串中进行尽可能多的匹配，有时候不需要这样的行为，可以在修饰符后面添加?来阻止这种行为，加了?之后，将会以非贪婪的模式进行匹配，尽量少的字符将会被匹配
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
			
	
	
		
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	