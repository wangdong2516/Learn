<center> 高性能Mysql读书笔记
</center>

1. Mysql的逻辑架构

    1. ![](/Users/wangdong/Library/Application Support/typora-user-images/image-20200315131347236.png)

2. 优化执行

    1. 查询语句sql --> Mysql解析器解析查询语句，并且创建内部数据结构(解析树) --> 优化器优化（重写查询、决定表的读取顺序、选择合适的引擎）-->  引擎层查询
    2. 在解析查询之前，服务器会先检查缓存、如果能在缓存中找到对应的查询的时候，直接返回缓存中的内容，而不去执行sql语句的解析】、优化和执行的流程。

3. 并发控制

    1. 当在同一时间修改数据的时候，都会存在并发的问题，会存在数据不一致的情况。

    2. 解决方案：

        1. 共享锁
            1. 也叫做读锁，是共享的，不相互阻塞。
        2. 排他锁
            1. 也叫做写锁，是排他的，会阻塞读锁和写锁。

    3. 锁的粒度

        1. 表锁
            1. 会锁定整张表，阻塞其他用户对这张表的读和写操作，只有没有写锁的时候，其他用户才会获取读锁，读锁之间是相互不阻塞的。
            2. 写锁会比读锁有更高的优先级，一个写锁的请求可能会插入到读锁队列的前面，但是读锁不能插入到写锁的前面。
            3. Mysql本身也会存在表锁，可以在服务器层锁定整张表，而忽略或者是跳过引擎层。
        2. 行锁
            1. 让锁定的对象更加具有选择性、只锁定需要修改的部分、锁定的数据量越少、并发程度越高。但是锁粒度小的话，带来的资源开销就会比较大，可能会影响系统的性能。
            2. 行级锁拥有最好的并发性能，行级锁也只在存储层实现而不在服务器层实现

    4. 数据库事务

        1. 事务的特性(ACID)
            + 原子性
                + 一个事务是一个最小的工作单元，是不可分割的、一个事务中的操作，要不全部成功，要不全部失败回滚
            + 一致性
                + 数据库中的数据总是从一个一致性的状态转换为另一个一致性的状态
            + 隔离性
                + 一个事务所做的修改在最终提交之前、对于其他的事务是不可见的
            + 持久性
                + 事务中所做的修改将会被持久保存在数据库中。

    5. 数据库的隔离级别

        1. 读取未提交(READ UNCOMMITTED)
            + 这种隔离级别会很容易造成脏读，因为会读取到未提交的数据，一般是很少使用的
        2. 读取已提交(READ COMMITTED)
            + 一个事务所做的修改在提交之前，对其他的任何事物是不可见的。这个隔离级别也叫做不可重复读，因为执行相同的查询，可能会得到不一样的结果。
        3. 可重复读(REPEATABLE READ)
            + mysql默认是隔离级别，在同一个事务中多次读取同样的记录是相同的。解决了脏读的问题，但是没有解决幻读的问题。
        4. 可串行化(SERIALIZABLE)
            + 强制事务串行执行，避免了幻读的问题，但是性能低，会造成超时和锁争用的问题，一般在对数据一致性要求比较高的情况下才会使用。

    6. 死锁

        1. 死锁指的是两个或者多个事务在同一资源上的相互争用，并且请求锁定对方占用的资源，从而导致循环的现象。
        2. 数据库系统实现了死锁检测机制和死锁超时检测机制，死锁的出现会导致慢查询。

    7. 事务日志

        1. 事务日志可以提高事务执行的效率，使用事务日志的时候，只需要在修改表数据的时候，修改其内存的拷贝，然后再将修改行为记录到持久在硬盘上的事务日志中，而不需要每次在修改数据的时候持久化到磁盘上。

        2. 事务日志的记录采用的是追加的形式，在内存中修改的数据可以在后台慢慢刷回磁盘。

        3. 查看或者是设置提交模式

            1. mysql默认的是自动提交模式

            2. ```sql
                SHOW VARIABLES LIKE 'AUTOCOMMIT'
                SET AUTOCOMMIT=1
                1或者是ON表示启用，0或者是OFF表示禁用。
                ```

            3. 设置隔离级别

                ```sql
                SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED
                ```

    8. 多版本的并发控制

        1. 一般情况下都实现了MVCC多版本并发控制

        2. MVCC可以认为是行级锁的变种、很多的时候避免了加锁的操作，开销更低。

        3. MVCC的实现是通过保存数据在某个时间点的快照来实现的，不管事务执行多长的时间，看到的数据都是一致的，

        4. Innodb引擎的MVCC实现

            + 是通过在每行记录中保存两个隐藏的列实现的，一个保存的是创建时间，一个保存的是删除时间，当不是真正的时间，而是系统的版本号，每开始一个新的事务，系统的版本号就回递增，事务开始的时候，系统的版本号就是当前事务的版本号，，用来和查询到的数据的版本号进行比较。
            + SELECT
                + 在数据中查找版本号<=当前事务版本号的行，保证了要不就是读取到之前已经修改的数据，要不就是在本次事务中修改的数据。
                + 行的删除时间要不没有定义，要不>当前事务的版本号，确保了记录在事务开始之前没有被删除。
            + INSERT
                + 为新插入的每一行数据保存当前系统的版本号作为行版本号
            + DELETE
                + 为删除的每一行保存当前系统的版本号作为删除版本号
            + UPDATE
                + 插入一条新的记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号作为原来行的删除版本号
                    ![image-20200315145930399](/Users/wangdong/Library/Application Support/typora-user-images/image-20200315145930399.png)

            + 幻读
                + 所谓幻读，就是指一个事务在进行读取某一个范围内数据操作的时候，另一个事务在当前的范围内插入了新的数据，当前的事物再次读取范围内的数据的时候，就会产生幻读。