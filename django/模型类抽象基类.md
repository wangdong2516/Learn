<center>Django模型
  
</center>

1. 关于抽象模型基类的说明

    + 抽象模型基类的定义和普通的模型类是一样的，只需要在Meta属性中，执行abstract属性为True即可
    + 抽象模型基类在进行迁移的时候，不会创建对应的数据库表
    + 抽象模型基类的使用情景追逐是将一些公共的属性和字段封装到一个类中，别的类直接继承抽象基类，就可以拥有其中定义的字段
    + 抽象模型基类在继承的时候，会将父类的Meta属性继承过来。
    + 如果像修改父类中定义的字段或者是属性的话，可以在子类中定义同名的字段或者是属性来达到覆盖的目的，或者是将其置为None来删除改字段
    + Django在抽象模型类继承的时候，会将其子类的abstract设置为False，这意味着抽象模型类的子类不会自动的成为一个抽象模型类。
    + 当你在抽象模型基类的Meta属性中定义了像db_table这样的属性的时候，会被所有的子类所继承，这就意味着所有的子类会拥有相同的数据库表名，这应该不会是你需要的。
    + 类似db_table属性，当你在抽象模型类的字段中指定了related_name或者是related_query_name这样的属性的话，会被所有的子类继承，你可以在其中使用app_label或者是class名来指定一个唯一的名字用来反向解析的时候使用。这是Django默认进行处理的。

2. 关于创建托管模型类的一些说明

    + 创建未托管模型类的方式是在模型类的Meta中指定managed属性，默认是True，这意味着Django将会管理数据库表的生命周期
    + 如果是False，则不会为该模型类在迁移的过程中执行创建或者删除的操作。如果模型表示通过其他某种方式创建的现有表或数据库视图，则此功能很有用。(数据库表是在Django迁移之前就已经存在了，不需要Django控制该表的生命周期)
    + 当managed=False的时候，这是和普通模型类之间唯一的区别，其他任何方面和普通的模型类是一样的。
    + 如果没有明确声明主键字段的话，将自动添加自增类型的主键字段，为了避免歧义，建议在使用非托管模型时从正在建模的数据库表中指定所有列。
    + 如果一个未托管模型类包含一个指向另一个未托管模型类的ManyToManyField，那么将不会创建用于多对多联接的中间表。但是，将创建一种托管模型和一种非托管模型之间的中间表。如果需要更改此默认行为，请将中介表创建为显式模型（根据需要使用托管集），然后使用ManyToManyField.through属性使关系使用自定义模型。

3. 使用Django使用旧的数据库

    1. 使用Django也可以管理和使用旧的数据库，他可以集成旧的数据库。
    2. Django 自带一个叫做 [`inspectdb`](https://docs.djangoproject.com/zh-hans/3.0/ref/django-admin/#django-admin-inspectdb) 的工具，它可以通过内省已存在的数据库创建对应模型。你能通过运行以下命令看到输出 python manage.py inspectdb

    3. 