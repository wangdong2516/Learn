## 常用的一些python模块
### os系统模块
	1. os.name: 输出字符串表示正在使用的平台
	2. os.getcwd(): 获得当前的工作目录
	3. os.listdir(): 返回指定目录下的所有文件和目录名,是一个列表
	4. os.remove(): 删除一个文件
	5. os.system(): 运行shell命令
	6. os.sep: 可以取代操作系统特定的路径分割符
	7. os.linesep: 给出当前平台使用的行终止符
	8. os.mkdir(): 创建一个目录
	9. os.path.exists(filename): 判断是否存在文件或者是目录名
	10. os.chdir(dirname): 改变工作目录到dirname
	11. os.path.basename(path): 返回文件名
	12. os.path.join(path, name): 连接目录和文件名或者目录，使用的是\进行连接
	13. os.rmdir(dirname): 删除一个目录，只能删除一级目录
## 一、 字符串的format方法
**format（）**：是从python2.6开始，新增的一种格式化字符串的方法，它可以替代之前的%s占位符

1. 基本的语法是：{}和：
2. format函数可以接受不限个数的参数，位置也可以不限顺序，如果不指定顺序的话，按默认的顺序进行格式化，指定了顺序，就按照顺序来格式化

```python
	例子：'{} {}'.format('hello', 'world')
	>>> hello world   (在这里没有指定顺序，按照默认的顺序进行格式化)
	'{0} {1}'.format('hello', 'world')
	>>> hello world  (这里指定了格式化的顺序，就按照顺序来进行格式化，format函数中第一个参数的索引值是0，以此类推)
	'{0} {1} {0}'.format('hello', 'world')
	>>> hello world hello   (也可以进行多次格式化)
```

3.format函数也可以设置参数

```python
'{name} is {gender}'.format(name='wangdong', gender='男')
>>> wangdong is 男
也可以通过字典设置参数
dict1 = {'name':'wangdong', 'gender':'男'}
>>>'{name} is {gender}'.format(**dict1)  # 在这里**的作用就是解包
>>> wangdong is 男
还可以根据列表的索引来设置参数
>>> list1 = ['wangdong', '男']
>>> '{0[0]} is {0[1]}'.format(list1)
>>> wangdong is 男
```

4.可以向format中传入对象

```python
class Person(object):
	def __init__(self, name):
		self.name = name

person = Person(wangdong)
>>> '我的名字是{.name}'.format(person)
>>> 我的名字是wangdong
```

5.其他

	1. 数字的格式化：
		{:.2f}    --->      保留两位小数
		{:+.2f}   --->      带符号的保留两位小数
		{:.0f}    --->      不保留小数
		{:0>2d}   --->      数字补零（填充左边，宽度为2）
		{:x:<4d}  --->      数字补x，填充右边，宽度为4
		{:,}      --->      以逗号的形式分割数字
		{:.2%}    --->      百分比格式
		{:.2e}    --->      指数
		{:10d}    --->      右对齐，默认，宽度为10
		{:<10d}   --->      左对齐，宽度为10
		{:^10d}   --->      中间对齐，宽度为10
	2. 解释：
		1. ^,<,>,分别是居中，左对齐和右对齐
		2. ：后面是待填充的字符串，只能是一个字符，不指定的话，默认是空格填充
		3. +：表示在正数前显示+，在负数前显示-
		4.  ：空格表示在正数前加空格
		5. b、d、o、x分别表示的是二进制，十进制，八进制、十六进制
		6. 我们可以使用{}来转义{} 
## 二、python中的解包方法
	1. 每一个可迭代对象都可以序列中的每一个元素赋值给变量来实现解包
	2. enuremate（）函数可以对于一个可迭代对象，将他们生成一个索引序列，使用这个函数可以同时获取可迭代对象中的元素和其对应的索引值
	可以实现即遍历索引，也遍历元素，enumerate函数返回的是一个enumerate对象
	enumerate()函数还可以接收第二个参数，这个参数是用来指定索引的起始值的
	使用enumerate函数可以统计文件的行数：
		count = 0
		for index, line in enumerate（open（filepath, 'r'）):
			count += 1
	3. 组包方式：
		组包是解包的逆过程，可以使用zip函数来实现，zip函数是python的内置函数，接收一系列可迭代对象作为参数，将可迭代对象中对应
		位置的元素打包成一个元祖，然后返回由这些元祖组成的列表，若参数的长度不一样，那么返回的列表将会和参数重长度最短的对象一致。
		例如：a = (1, 2, 3)
			  b = ('a', 'b', 'c')
			  for i in zip(a, b):
			  		print(i) 
	4. 组包和解包同时使用
		1. 例子：
			for i, j in zip([1,2,3],['a','b','c']):
				print(i,j)
			理解：先将两个可迭代序列组包，打包成一个元祖，然后用两个变量将元祖解包
	5. 在函数定义的时候，我们可以使用*args接收可变参数，**kwargs接收关键字参数，可变参数的传值，使用元祖的形式，当只有一
	个元素的时候，元祖中的元素后面需要加,，关键字参数使用key=value的形式传值，实质上就是组包和解包的过程
## 三、python解释器
	1.如果可能的话，解释器会读取命令行参数，转化为字符串列表存入 sys 模块中的 argv 变量中。执行命令 import sys 你可以导入这个模块并访问这个列表。这个列表最少也会有一个元素；
	如果没有给定输入参数，sys.argv[0] 就是个空字符串。如果脚本名是标准输入，sys.argv[0] 就是 '-'。使用 -c command 时，sys.argv[0] 就会是 '-c'。如果使用选项 -m module，sys.argv[0] 就是包含目录的模块全名。
	在 -c command 或 -m module 之后的选项不会被解释器处理，而会直接留在 sys.argv 中给命令或模块来处理。	
	2. 在交互模式下，上一次打印出来的表达式被赋值给变量 _。这意味着当你把Python用作桌面计算器时，继续计算会相对简单
	例子：name = 'wandong'
	>>>  name
		wangdong
	>>>  _ + 'age'
		wangdongage
## 四、正则表达式
				-----摘自https://python3-cookbook.readthedocs.io/zh_CN/latest/c02/p06_search_replace_case_insensitive.html
	1. 正则表达式可以拼接； 如果 A 和 B 都是正则表达式， 那么 AB 也是正则表达式。 通常， 如果字符串 p 匹配 A 并且另一个字符串 q 匹配 B, 
	 那么 pq 可以匹配 AB。除非 A 或者 B 包含低优先级操作，A 和 B 存在边界条件；或者命名组引用。所以，复杂表达式可以很容易的从这里描述的简单源语表达式构建。
	 2. re.compile(pattern, flag):这个是Pattern的工厂函数，用于将字符串形式的正则表达式编译为Pattern对象，flag表示的是匹配模式。可选的匹配模式有：I（忽略大小写），M（多行模式），S（.任意匹配模式，改变.的行为）,X（详细模式）	re.compile的应用场景就是：在使用re.match或者是re.search进行匹配的时候，python会将字符串转换为正则表达式对象（当你想使用同一个模式进行多次匹配的时候，
	 你应该先将模式字符串预编译为模式对象）
	 但是使用re.compile()函数之后，会将正则表达式字符串编译为Pattern对象，在使用相同的匹配规则的情况下，可以使用同一个Pattern对象，加快速度
	 re.compile()函数接收一个标志参数re.DOTALL,它可以让正则表达式中的（。）匹配包括换行符在内的字符
	 3. re.split()：当匹配到符合正则表达式的内容之后，将对象两边的实体当成结果中的元素进行返回。以列表的形式返回。
	 当你使用re.split()的时候，特别需要注意的是正则表达式中是否包含一个括号捕获分组，如果使用了捕获分组，那么被匹配的文本也将出现在结果列表中。
	 如果你不想保留分割字符串到结果列表中去，但仍然需要使用到括号来分组正则表达式的话， 确保你的分组是非捕获分组，形如 (?:...) 。
	 4. re.match():总是从字符串的开头去匹配，查找到了就会返回
	 5. 如果你想查找字符串任意部分的模式出现位置，使用findall()方法来代替
	 6. 如果你想以迭代的方式返回匹配，可以使用finditer()方法来替代
	 7. 当你准备做大量的匹配和搜索操作的时候，最好的是先预编译正则表达式，然后重复的使用，模块级别的函数会将最近编译的模式进行缓存，
	 并不会消耗太多的性能，但是如果使用的是预编译模式的话，将会减少查找和一些额外处理的损耗。
	 8. sub（）函数中的第一个参数是被匹配的模式，第二个参数是替换模式，第三个参数是匹配的文本
	 9. 对于更加复杂的替换，可以考虑传递一个替换回调函数来代替，一个替换回调函数的参数是一个match对象，也就是match()或者是find（）返回的对象，使用group（）方法来获取特定的匹配部分，回调函数最后返回替换的字符串
	 10. 如果除了替换的结果之外，还想知道有多少替换发生了，可以使用re.subn()来替代
	 new_text, n = re.sub(r'(\d+)/(\d+)/(\d+)/', r'\3-\1-\2', text)
	 new_text --> 'Today is 2012-11-27. PyCon starts 2013-3-13.'
	 n ---> 2
	 11. 忽略大小写，在flag中设置re.NGNORECASE标志参数，但是替换字符串并不会跟被匹配的字符串大小写保持一致
## 五、字符串的操作
	1. strip（）方法可以删除字符串中不需要的字符，不仅仅可以删除空格,但是strip（）只会删除字符串开头或者是结尾的字符，而不能删除中间的字符。
	2. str.translate()方法：根据参数table给出的表转换字符串中的字符，要过滤掉的字符放到del参数中
	语法：str.translate(table,deletechars)
		table --- 翻译表
		deletechars -- 字符串中要过滤的字符串
	3. 如果你想要合并的字符串在一个序列中或者是iterable中，那么最快的方式就是使用join（）方法。
	4. 字符串的format()方法可以格式化字符串，如果被替换的字符串能在变量域中找到的话，也可以使用format_map()和vars()使用,vars()也可以适用于对象的实例。
	但是format（）和format_map()并不能应对变量缺失的情况。
	例子：str1 = '{name} is {age}'
		  name = 'wangdong'
		  age = '12'
		  str1.format_map(vars())
	--->  wangdong is 12
## 六、format函数
	1. 注意：format函数不同于字符串的format方法，format函数可以用来对齐字符串，使用的时候<、>、^后面跟一个指定的宽度
	2. format函数的好处就是它可以用来格式化任何值，需要格式化字符串的时候，优先使用的是format函数或者是字符串的format方法，要比占位符更加的强大
## 数字、日期和时间
	1. 简单的舍入运算，使用内置的round(value, ndigits)函数，ndigits表示的是需要保留几位小数。
## 控制文字字数
	1. 当文字超过需要显示的字数限制的时候，可以使用css的属性：text-overflow: ellipsis来设置当文本溢出的时候需要发生的事情。
## 关于pycharm的使用
	1. command+g：输入指定的行数，可以跳转到指定的行数
	2. command+r:全局搜索替换
	3. 两次shift，搜索文件
	4. 