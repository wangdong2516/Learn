# HTTP协议
## 概念
	1. TCP/IP协议族
		1. 通常使用的网络是在TCP/IP的基础上运作的，HTTP协议只是TCP/IP协议的一个子集
	2. TCP/IP协议的分层
		1. 按层次可以分为(从上到下): 应用层 -- 传输层(负责给应用层提供数据) -- 网络层(负责数据包在网络上的传输) -- 数据链路层(负责接收数据)。
		2. 应用层决定了向用户提供应用服务时的通信活动（FTP（文件传输协议），DNS（域名解析协议），HTTP（超文本传输协议））。
		3. 传输层提供处于网络连接中两台计算机之间的数据传输（TCP（传输控制协议），UDP（用户数据报协议））。
		4. 网络层用来处理在网络上流通的数据包，数据包是网络中进行数据传输的最小数据单位。
		该层规定了通过怎样的路径到达对方的计算机，并把数据包传送给对方。
		5. 链路层用来处理连接网络的硬件部分，硬件上的范畴均在链路层的作用范围之内。
	3. 在使用HTTP进行通信的时候，发送端是从应用层向下走，接收端是从链路层向上走
	发送端每经过一层，就会增加一层首部，接收端每经过一层，就会删除一层首部。
## IP协议
	按照层次来分，IP协议位于网络层。
	1. IP协议的作用就是把各种数据包发送给对方，而且需要保证确实是传到了对方手里，其中起到重要作用的就是IP地址和MAC地址
	2. IP地址表示节点被分配到的地址，MAC地址是指网卡所属的固定地址，IP地址和MAC地址进行配对，IP地址是可以变化的，但是MAC地址一般是不会改变的
	3. ARP协议是一种用来解析地址的协议，通过IP地址就可以查出对应的MAC地址。
## TCP协议
	1. 按层次来划分，TCP协议是属于传输层的，提供可靠的字节流服务。
	2. 所谓的字节流服务指的是为了方便传输，将大块的数据分割成以数据报文为单位的数据包进行传输，
	可靠的传输服务指的是能够确保数据准确的传输到接收方。
	3. 为了保证数据包能够准备的传输，TCP使用了三次握手，在三次握手中使用了标志位：SYN和ACK
	4. 三次握手的过程：
		1. 发送端首先发送一个带有SYN标志位的数据包，SYN表示这是一个请求连接的报文
		2. 接收端接受到请求连接的报文之后，向发送端发送一个带有SYN和ACK标志位的报文，ACK表示这是一个确认报文
		3. 发送端接受到接收端发送的报文之后，再次发送一个带有ACK标志位的报文给接收端，表示连接成功。三次握手结束
## DNS域名解析
	按照层次来分，DNS协议是位于应用层的协议。
	1. DNS协议是用来解析域名和域名对应的IP地址之间的协议，DNS协议可以通过域名查找IP地址，或者可以通过IP地址反向查找域名。
	2. 在通过域名请求的时候，首先经过DNS协议将域名解析成对应的IP地址之后，返回给浏览器，然后浏览器请求对应的IP地址，就能获取到
	对应的资源了
## URI和URL
	1. URI：统一资源标识符，URI使用字符串标识某一个互联网资源
	2. URL：统一资源定位符，URL表示资源处在的位置地点
	3. URL是URI的子集
	4. 表示指定的URI，要使用涵盖全部必要信息的绝对URI，绝对URL和相对URL
	5. 相对URL指的是从浏览器中基本URI初指定的URL
	6. 绝对URI的格式：协议版本（必选）+登录信息（可选）+ 服务器地址（必选）+ 端口号（可选）+ 带层次的文件路径（必选）+ 查询字符串（可选） + 片段标识符（可选）
## 简单的HTTP协议
	1. HTTP协议规定，请求首先从客户端发出，最终服务器端响应该请求并且返回数据。
	2. 请求报文的格式：
			请求行：GET /index.html HTTP/1.1
					GET 表示请求方式  /index.html表示URI  HTTP/1.1表示协议版本
			请求头: HOST、USER_AGENT,CONTENT_LENGTH等
			空行：\r\n
			请求体: get请求一般没有请求体
	3. 响应报文的格式：
			响应行：HTTP/1.1 200 OK
					HTTP/1.1表示协议版本， 200表示状态码， OK表示对于状态码的描述
			响应头：COOKIE，CONTENT_LENGTH，CONTENT_TYPE
			空行：\r\n
			响应体：数据
	4. HTTP是一种无状态的协议，不对请求和响应之间的状态进行保存。
	5. HTTP请求方式：
		1. GET：获取资源
		2. POST：保存数据，传输实体
		3. PUT：修改数据，传输文件
		4. HEAD：获得报文头，不返回报文主体，只返回报文头
		5. DELETE：删除文件
		6. OPTIONS：查询服务器所支持的请求方式
		7. TRACE：追踪路径，让服务端将之前的请求通信环回给客户端的方法(在发送亲求的时候，在MAX_Forwards中写入相应的数值，在传输的时候，每经过一个服务器端，该数值就会减1， 直到减到0为止，就会停止传输，最后接收到请求的
			服务器端作出对应的响应)
			客户端可以通过TRACE方法追踪发出去的请求是怎么被篡改的，TRACE方法可以追踪其中发生的一系列操作。
		8. CONTENT：要求用隧道协议连接代理
			CONTENT方法的格式如下：CONTENT 代理服务器名：端口名 协议版本
	6. 持久连接
		1. 持久连接的特点是：只要任意一端没有明确断开连接，则保持TCP的连接状态
		2. 持久连接的好处在于减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载，提高了网页的响应速度
		3. 在HTTP/1.1中，所有默认的连接都是长连接（持久连接） 
		4. 持久连接使得多数请求以管线化方式发送成为可能，可以不用等待响应也可以直接发送下一个请求。
## 使用cookie进行的状态管理
	1. HTTP是无状态协议，它不对之前发生过的请求和响应的状态进行保存，也就是说，无法根据之前的状态进行本次请求的处理。
	2. Cookie技术通过在请求和响应报文中写入cookie信息来控制客户端的状态。
	3. Cookie会根据从服务器端发送的响应报文内Set-Cookie的字段信息，通知客户端保存Cookie，当下次
	客户端再次向服务器端发送请求的时候，会自动在请求报文中添加Cookie的值并且发送出去。
## HTTP报文
	1. HTTP报文本身是由多行数据构成的字符串文本，用于HTTP协议交互的信息被称为HTTP报文。
	2. HTTP在传输数据的时候，可以按照数据的原貌进行直接传输，也可以通过编码来提升传输的效率，但是会消耗更多的CPU资源。
	3. 报文主体和实体主体的差异：
		1. 报文：是HTTP通信中的基本单位，由8位组字节流组成，通过HTTP通信传输。
		2. 实体：作为请求和响应的有效载荷数据被传输，其内容由实体首部和实体主体组成。
		3. HTTP报文的主题用于传输请求或响应的实体的主体
		4. 通常情况下，报文主体和实体主体是一样的，只有当传输中进行编码操作的时候，实体主体的内容发生变化，才导致和报文主体产生差异。
	4.内容编码：指明应用在实体内容上的编码格式，并且保持实体信息原样压缩，内容编码之后的实体由客户端接收并且负责解码。
	5. 常用的内容编码：
		1. gzip
		2. compress(UNIX系统的标准压缩)
		3. deflate(zlib)
		4. identity(不进行编码)
	6. 分块传输编码 
		1. 在HTTP通信过程中，请求的编码实体资源尚未全部传输完成之前，
		浏览器无法显示请求的页面，在传输大容量数据的时候，通过把数据分割成多块，能够让浏览器逐步显示页面。
		2. 这种把实体主体分块的功能称为分块传输编码
		3. 分块传输编码会将实体主体分为多个块，每一块都会使用十六进制来标记块的大小，而实体主体的最后一块会使用0来标记.
		4. 使用分块传输编码的实体主体会由接收的客户端负责解码，恢复到编码之前的实体主体。
	7. 获取部分内容的范围请求：
		1. 指定范围发送的请求叫做范围请求。
		2.  执行范围请求的时候，会使用到请求头部中的Range字段来指定资源的byte范围
			Range: bytes=50001-100000
		3. 针对范围请求，响应会返回状态码206的响应报文，如果服务器端无法响应范围请求，就会返回状态码200 OK和完整的实体内容。
	8. 内容协商返回最合适的内容
		1. 同一个web网站可能存在多份相同内容的页面，它们在内容上相同，但是使用的语言不同。
		2. 如果浏览器的默认语言是英文的时候，请求相同的URI,就会显示不同的页面，这样的机制叫做内容协商。
		3. 内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为合适的资源，内容协商会以响应资源的语言，字符集，编码方式等作为判断的标准。
		4. 内容协商字段：
			1. Accept: 可接收的文本类型
			2. Accept-Charset: 可接收的字符集
			3. Accept-Encoding: 可接收的编码方式
			4. Accept-Language: 可接收的语言
			5. Content-Language： 文本内容的语言
		5. 内容协商技术由三种类型：
			1. 服务器驱动协商：由服务器端进行内容协商
			2. 客户端驱动协商：由客户端进行内容协商
			3. 透明协商：由服务器和客户端一起进行内容协商
## HTTP状态码
	1. 1开头
		1xx（临时响应）表示临时响应并且需要请求者继续执行操作的状态码
		1. 100（继续）请求者应当继续提出请求，服务器返回此代码表示已经接收到请求的一部分，正在等待剩余的部分。
		2. 101（切换协议）请求者已要求服务器切换协议，服务器已确认并且准备切换
	2. 2开头
		2xx（成功）表示成功处理了请求的状态码
		1. 200（成功）服务器已经成功处理了请求，通常表示服务器提供了请求的网页
		2. 201（已创建） 请求成功并且服务器创建了新的资源
		3. 202（已接受） 服务器已经接受请求，但尚未处理
		4. 203（非授权信息） 服务器已经成功处理了请求，但返回的信息可能来自另外的源
		5. 204（无内容） 服务器成功处理了请求，但是没有返回任何内容
		6. 205（重置内容） 服务器成功处理了请求，但是没有返回任何内容
		7. 206（部分内容） 服务器成功处理了部分GET请求，通常是客户端进行范围请求的时候使用
	3. 3开头
		3xx（重定向） 表示要完成请求，需要进行一步操作，通常，这些状态码用来重定向
		1. 300（多种选择）针对请求，服务器可以执行多种操作，服务器可以根据请求者选择一项操作，或者提供列表供请求者选择。
		2. 301（永久移动）：请求的网页已经永久移动到新的位置，服务器返回此响应，会自动将请求者赚到新的位置。
		3. 302（临时移动）。服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求
		4. 303（查看其他位置） 请求者应当对不同的位置使用单独的GET请求来检索响应的时候，服务器就会返回此代码
		5. 304（未修改） 自从上次请求之后，请求的网页未修改过，服务器返回此响应的时候，不会返回网页的内容
		6. 305（使用代理） 请求者只能使用代理开请求访问的网页，如果服务器返回此响应，还表示请求者应该使用代理
		7. 307（临时重定向） 服务器目前从不同的位置的网页响应请求，但是请求者应继续使用原有的位置来进行以后的请求
	4. 4开头
		4xx（请求错误）这些状态码表示请求可能出错，妨碍了服务器的处理
		1. 400（错误请求）。服务器不理解的请求语法
		2. 401（未授权） 请求要求验证身份，对于需要登录的网页，服务器可能会返回此响应。
		3. 403（禁止） 服务器拒绝请求
		4. 404（未找到） 服务器找不到请求的网页
		5. 405（方法禁用） 禁止使用请求中指定的方法
		6. 406（不接受） 无法使用请求的内容特性响应请求的网页
		7. 407（需要代理授权） 此状态码和401类似，但是指定了请求者应当授权使用代理
		8. 408（请求超时） 服务器等候请求的时候，发生了超时
		9. 409（冲突） 服务器在完成请求时发生了冲突，服务器必须在响应中包含冲突的相关信息
		10. 410（已删除） 如果请求的资源已经永久删除，服务器就会返回该状态码
		11. 411（需要有效长度） 服务器不接受不含有效长度字段的请求
		12. 412（未满足前提条件）  服务器未满足请求者在请求设置中的其中一个前提条件
		13. 413（请求体过大） 服务器无法处理请求，因为请求体过大，超出了服务器的处理能力
		14. 414（请求的url过长） 请求的URL过长，服务器无法处理
		15. 415（不支持的媒体类型） 请求的格式不受请求页面的支持
		16. 416（请求范围不符合要求） 如果页面无法提供请求范围，服务器就会返回该状态码
		17. 417（未满足期望值） 服务器未满足期望请求头字段的要求
	5. 5开头
		5xx表示服务器在尝试处理请求的时候发生内部错误，这些错误可能是服务器本身的错误，而不是请求出错
		1. 500（服务器内部错误） 服务器遇到错误，无法完成请求
		2. 501（尚未实施） 服务器不具备完成请求的功能
		3. 502（错误网关） 服务器作为网关或者是代理，从上游服务器获取到无效的响应
		4. 503（服务不可用） 服务器目前无法使用，这只是暂时状态
		5. 504（网关超时） 服务器作为网关或者是代理们但是没有及时从上游服务器收到请求
		6. 505（HTTP版本不支持） 服务器不支持请求中所使用的HTTP协议版本
	1. 状态码的作用是描述返回的请求结果。借助状态码，可以知道服务器端是否正常处理了请求。
	2. 状态码的类别：
		1. 1xx:信息类状态码表示接收的请求正在处理
		2. 2xx：成功状态码，表示请求正常处理完毕
		3. 3xx：重定向状态码，表示需要进行附加操作来完成本次的请求
		4. 4xx：客户端错误状态码，表示服务器无法处理请求
		5. 5xx：服务器错误状态码：服务器处理请求错误
	3. 常用的状态码：
		1. 200（OK）: 请求正常处理
		2. 204（No Content）：请求成功处理，但是没有响应内容,也不允许返回响应的内容。(一般在客户端需要往服务器端发送信息，但是服务器端不需要给
		客户端返回信息的时候使用)
		3. 206（Partical Content）：客户端进行了范围请求，服务器成功执行了这部分get请求，响应报文中包含了Content-Range指定范围的实体内容
		4. 301（Moved Permanently）：永久性重定向，该状态码表示请求的资源被分配到了新的URI，以后应该使用新的URI，响应头部的Location字段表明重定向之后的位置
		比如：请求index的时候，没有加/，就会返回301状态码
		5. 302（Found）：临时重定向，该状态码表示请求的资源已经被分配到新的URI，希望用户在本次能够使用新的URI访问
		301和302状态码的区别在于一个是永久重定向，301会将URI进行重新保存，而302不会保存，只是在本次请求的时候使用。
		6. 303（See Other）：查看其他位置，该状态码表示由于请求对应的资源存在另外一个URI，应使用GET方法定向获取请求的资源。
		303和302的区别在于：303指定了客户端应该使用get方式来获取对应的资源，而302并没有指定
		7. 304（Not Modified）：未修改，该状态码表示客户端发送附带添加的请求时，服务器端允许请求访问资源，但是没有满足条件的情况。304状态码返回的时候，不包含响应的主体
		8. 307（Temporary Redirect）：临时重定向
		9. 400（Bad Request）：错误的请求，表示请求报文中的语法存在错误
		10. 401（Unauthorized）：未认证或者是认证失败，表示在请求中需要认证信息，如果已经认证了，那么表示认证失败。
		11. 403（Forbidden）：禁止访问,对请求资源是拒绝访问的，服务器端可以在响应体中给出原因，但不是必须的。
		12. 404（Not Found）：页面找不到，服务器中没有请求的资源，可以在拒绝请求但是不想说明原因的时候使用.
		13. 500（Internal Server Error）： 服务器内部错误，可能是服务器端的错误，也可以是web端参数传递错误导致的。
		14. 503（Service Unavailable）：服务器暂时处于超负荷或者是维护的状态中，无法处理请求。
	4. Connection字段的作用：1. 控制不再转发给代理的首部字段  2. 管理持久连接（长连接）
	5. Date字段：创建HTTP报文的日期和时间。
	6. Trailer：说明在报文主体之后记录了那些首部字段，该首部字段可用于分块传输编码。
	7. Transfer-Encoding：传输报文主体的时候采用的编码方式。
## 单台服务器拥有多个域名
	1. 在很多情况下，一台服务器中可以存在多个域名，但是当用户使用域名来进行访问的时候，首先经过DNS服务器解析得到域名对应的IP地址，但是如果一台服务器
	中存在多个域名的情况下（web托管服务），访问不同的域名，将会得到相同的IP，怎么判断到底访问的是这台服务器中的那个服务呢？
	在请求头部中的HOST字段中指明指定的主机名和域名
## 代理、网关、隧道
	1. 代理：是一种有转发功能的应用程序，扮演了客户端和服务器之间中间人的角色，接收由客户端发送的请求并且转发给服务器，同时也接收从服务器发送的响应再发送给客户端
	2. 网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的资源服务器一样对请求进行处理。
	3. 隧道：是在遥远的客户端和服务器之间进行中转，并且保持双方通信连接的应用程序。不会解析HTTP请求，保持原样中转。
	4. 每次经过代理转发请求或者是响应的时候，会在Via首部加入信息，标记经过的主机信息。
	5. 使用代理服务器的理由：利用缓存技术减少网络带宽，组织内部针对特定网站的访问控制，获取访问日志
	6. 代理的两种使用方式：1. 缓存代理 2. 是否会修改报文
	7. 缓存代理：代理转发响应的时候，缓存代理会预先将资源的副本缓存在代理服务器上，当再次接受到对相同资源的请求的时候，直接返回，这种代理被称为缓存代理服务器
	目的在于节约带宽，减少通信的时间和流量
	8. 透明代理：转发请求或者是响应的时候，不对报文做任何加工的代理
	9. 非透明代理：转发请求或者是响应的时候，对报文做加工的代理

## 范围请求
	1. 范围请求是为了解决由于网络问题或者是文件太大造成的无法一次性传输完成，传输中断之后继续获取的问题
	2. 范围请求需要用到请求头部字段：Range来指明请求的范围
	3. 服务器端在可以处理范围请求的情况下，会返回状态码 206 Partical Content作为影响，
		并且将Content-Type设置为multipart/byteranges
		如果服务器端无法处理范围请求，就会返回200状态码和实体的全部内容
## 通用首部
	1. Cache-Control：控制缓存的行为
		缓存请求指令：
			no-cached --> 强制向源服务器再次验证
			no-store --> 不缓存请求或者是响应的任何内容
			max-age --> 响应的最大Age值
			max-stale -->	 接收已经过期的响应
			min-fresh --> 期望在指定的时间内响应任然有效
			no-transform --> 代理不可更改的媒体类型
			only-if-cached --> 从缓存中获取资源
			cache-extension --> 新指令标记
		缓存响应指令：
			public --> 可向任意方提供响应的缓存
			private --> 仅向特定用户返回响应
			no-cache --> 缓存前必须确定有效性
			no-store --> 不缓存请求或者是响应的任何内容
			no-transform --> 代理不可更改的媒体类型
			max-age --> 响应的最大Age值
		注意：no-cache表示的是不缓存过期资源
			  no-store表示的是不缓存任何资源
	2. Connection首部的作用：
		1. 删除在下次传输的时候不再进行转发的字段
		2. 表明连接的类型是长连接还是短链接
	3. Date字段：表明了创建请求报文或者是响应报文的时间
	4. Upgrade字段：用来检测协议是否可以升级成更高级的协议版本，比如http--> https
## 请求头部字段
	1. Accept字段：指明了客户端能够处理的媒体类型和类型的优先级（通过权重q来指定）
	2. Accept-Language字段：指明了客户端能够处理的语言类型和类型的优先级顺序（通过权重值指定）
	3. Accept-Encoding字段：指明了客户端能够处理的内容编码方式和编码的优先级顺序（通过权重值q来指定）
	4. Accept-Charset字段：指明了客户端能够处理的字符集，以及字符集的优先顺序（通过权重值q来指定）
	5. Authorization字段：指明了当服务器需要认证信息的时候，客户端提供的认证信息
	6. Host字段：指明了主机名和端口，特别是在一台服务器上部署有多个域名的服务的时候，起到很大的作用，因为IP地址相同，Host字段
		可以用来区分访问的是哪一个服务。
	7. Range字段：发送范围请求的时候，需要携带的字段，表明了客户端请求的资源范围
	8. Referer字段：用来表明用户是从那个页面跳转来的
	9. User-Agent字段：会将创建请求的浏览器和用户代理等名称携带到User-Agent字段中
## 响应头部字段
	1. Accept-Renages字段：表明了服务器是否可以处理范围请求，如果可以处理的话，返回bytes，不能处理的话，返回none
	2. Age字段：服务器告知客户端，响应的创建时间
	3. Location字段：用来告知客户端，引导到指定的位置url上，通常是和3xx状态码配合使用
## 实体首部字段
	1. Allow字段：告知客户端，服务器端对指定资源的访问方式，返回的是请求方法,一般是配合405状态码来使用，当请求方式不被允许的时候，
					会通过Allow字段来指明服务器端允许的请求方式。
	2. Content-Encoding字段：告知客户端，响应内容的编码方式
	3. Content-Language字段：告知客户端，响应内容的语言。
	4. Content-Length字段：告知客户端，响应内容的长度
	5. Content-Range字段： 告知客户端，针对范围请求，告知客户端作为响应返回的实体的哪个部分的范围请求
	6. Content-Type字段：告知客户端，实体采用的媒体类型。
## 为Cookie服务的字段
	1. Set-Cookie: 响应头字段，表明了开始状态保持所使用的cookie信息
		name=value。cookie的名称和值
		expires=DATE。cookie的有效期，当省略expires的时候，其有效期限于会话期间，一旦客户端发送了cookie，服务器端就不能删除cookie，但是可以通过写入新的cookie覆盖来实现类似删除的操作
		path=PATH  将服务器上的文件目录作为cookie的适用对象
		domain=域名   cookie适用的域名
		secure： 仅在https通信的时候才会发送cookie
	2. Cookie: 请求头字段，请求的时候携带的cookie信息。 
## 确保web安全的HTTPS
	1. HTTPS就是HTPP+SSL（TSL）
	2. SSL是独立于HTTP的协议，任何协议都可以搭配SSL协议加密使用
	3. 共享密钥加密技术：
		1. 加密和解密使用的是同一个密钥的方式叫做共享密钥加密，也叫做对称密钥加密
	4. 公开密钥加密技术：
		1. 公开密钥加密技术使用一对非对称的密钥，一把叫做私有密钥，一把叫做公开密钥，也叫做非对称加密
		2. 发送报文的一方使用对方的公开密钥进行加密，对方在接收到报文之后，使用自己的私有密钥进行解密，保证的信息的安全传输。
	5. HTTPS采用的是混合加密机制：
		1. HTTPS采用共享密钥加密和公开密钥加密混用的混合加密机制
	6. HTTPS的通信过程：
		1. 客户端发送ClientHello的报文开始ssl通信，报文中包含了客户端支持的ssl版本和加密组件列表（加密算法和密钥的长度）
		2. 服务器端可以进行SSL通信的时候，会以Server Hello的报文作为响应，报文中包含了客户端支持的ssl版本和加密组件列表（加密算法和密钥的长度）
		3. 之后服务器端发送带有Certificate报文，报文中包含公开密钥证书
		4. 最后服务器端发送Server Hello Done的报文，通知客户端，最初阶段的SSL握手结束
		5. SSL握手结束之后，客户端发送Client Key Change的报文，报文中包含一个用于加密的随机密码串，这个报文已经使用公开密钥进行了加密
		6. 紧接着客户端发送Change Cipher Spec报文，该报文会提示服务器，之后的通信采用的是随机密码串加密的方式
		7. 客户端发送Finish报文，该报文包含了连接以来报文的整体校验值，握手协商是否能成功，关键在于服务器能否正确解密报文
		8. 服务器端发送Change Cipher Spec报文，使用的是客户端指定的随机密码串加密的方式
		9. 服务器端发送Finish报文
		10. 服务器端和客户端的Finish报文交换完成之后，SSL的握手正式结束，开始进行HTTP通信
		11. 断开连接的时候，发送close notify报文，断开连接，在发送FIN报文断开和TCP的连接
## 确认用户访问身份的认证
	1. HTTP使用的认证方式：
		1. BASIC认证（基本认证）
		2. DIGEST认证（摘要认证）
		3. SSL客户端认证
		4. FromBase认证（基于表单认证）
	2. Cookie和Session基于表单认证的方式
		1. 基于表单的认证方式本质上是将用户ID和密码和之前注册或者是登录的ID和密码来进行一个匹配的
		2. 流程：
			1. 客户端将用户ID和密码放到请求体中，以POST方式发送给服务器
			2. 服务器验证成功之后，会发放用来识别用户身份的SessionID，把用户认证和SessionID进行绑定之后，存储在服务器端
			3. 服务器端返回响应的时候，会在Set-Cookie中写入SessionID信息，为了防止SessionID被盗，应尽量使用难以破解的字符串，并且需要进行有效期的管理
			4. 客户端接收到服务器端返回的报文之后，将Set-Cookie字段中的信息放到Cookie中保存，下次请求的时候，自动携带Cookie信息
## 基于HTTP的功能追加协议
	1. SPDY协议：
	2. Ajax技术：异步页面刷新技术
	3. Comet技术：解决一次请求一次响应的问题，Comet会将当前的响应挂起，等到服务器上有资源进行更新了，才会返回响应
	4. WebSocket协议：解决HTTP协议请求只能由客户端发起，无法对服务器上的更新进行实时获取，只能使用轮询的方式获取，但是轮询的方式是非常消耗资源的
			WebScoket最大的特点是：服务器可以给客户端发送消息，客户端也可以给服务器发送消息
			双工通信，属于一种推送的技术
				
## 针对Web的攻击技术
	1. 简单的HTTP协议本身不存在安全性的问题，因此协议本身不会成为攻击的对象，应用HTTP协议的服务器和客户端，以及运行在服务器上的web应用等资源才是攻击的目标。
	2. 在客户端就可以篡改请求：在HTTP请求报文内加载攻击代码，就能发起对web应用的攻击，通过URl查询字符串或者是表单，HTTP首部、cookie等途径将攻击代码传入，内部信息就会泄漏。
	3. 针对Web应用的攻击模式：
		1. 主动攻击：以服务器为目标，是指攻击者通过直接访问web应用，把攻击代码传入的攻击模式
		主动攻击模式里最具代表性的是sql注入和os命令注入攻击
		2. 被动攻击：以服务器为目标，是指利用圈套策略执行攻击代码的攻击模式，在被动攻击的过程中，攻击者不直接对目标web应用发起攻击。
		3. 被动攻击的步骤：
			1. 攻击者诱使用户出发已经设置好的陷阱，而陷阱会启动发送已经嵌入攻击代码的HTTP请求
			2. 当用户不知不觉中招的时候，用户的浏览器或者是邮件客户端就会出发这个陷阱。
			3. 中招以后的用户浏览器你把含有攻击代码的HTTP请求发送给作为攻击目标的Web应用，运行攻击的代码
			4. 执行完攻击代码，存在安全漏洞的web应用会成为攻击者的跳板，可能导致用户所持有的cookie等个人信息被窃取，登录状态中的用户权限遭到滥用等后果
			5. 被动攻击模式中具有代表性的是跨站脚本攻击和跨站请求伪造。
	4. 跨站脚本攻击：
		1. 跨站脚本攻击指的是通过存在安全漏洞的web网站注册用户的浏览器内运行非法的HTML或者是js代码的一种攻击手段
	5. OS注入攻击
		指的是通过web应用，执行非法的系统操作命令从而达到攻击的目的。
	6. HTTP首部注入攻击：
		指的是  
	